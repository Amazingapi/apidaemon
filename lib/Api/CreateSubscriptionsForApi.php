<?php
/**
 * CreateSubscriptionsForApi
 * PHP version 7.4
 *
 * @category Class
 * @package  com.cryptoapis.rest_apis.sdk
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * CryptoAPIs
 *
 * Crypto APIs is a complex and innovative infrastructure layer that radically simplifies the development of any Blockchain and Crypto related applications. Organized around REST, Crypto APIs can assist both novice Bitcoin/Ethereum enthusiasts and crypto experts with the development of their blockchain applications. Crypto APIs provides unified endpoints and data, raw data, automatic tokens and coins forwardings, callback functionalities, and much more.
 *
 * The version of the OpenAPI document: 2023-04-25
 * Contact: developers@cryptoapis.io
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.4.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace com.cryptoapis.rest_apis.sdk\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use com.cryptoapis.rest_apis.sdk\ApiException;
use com.cryptoapis.rest_apis.sdk\Configuration;
use com.cryptoapis.rest_apis.sdk\HeaderSelector;
use com.cryptoapis.rest_apis.sdk\ObjectSerializer;

/**
 * CreateSubscriptionsForApi Class Doc Comment
 *
 * @category Class
 * @package  com.cryptoapis.rest_apis.sdk
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class CreateSubscriptionsForApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'blockHeightReached' => [
            'application/json',
        ],
        'minedTransaction' => [
            'application/json',
        ],
        'newBlock' => [
            'application/json',
        ],
        'newConfirmedCoinsTransactions' => [
            'application/json',
        ],
        'newConfirmedCoinsTransactionsAndEachConfirmation' => [
            'application/json',
        ],
        'newConfirmedInternalTransactions' => [
            'application/json',
        ],
        'newConfirmedInternalTransactionsAndEachConfirmation' => [
            'application/json',
        ],
        'newConfirmedTokensTransactions' => [
            'application/json',
        ],
        'newConfirmedTokensTransactionsAndEachConfirmation' => [
            'application/json',
        ],
        'newRevertedBlock' => [
            'application/json',
        ],
        'newUnconfirmedCoinsTransactions' => [
            'application/json',
        ],
        'newUnconfirmedTokensTransactions' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation blockHeightReached
     *
     * Block Height Reached
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\BlockHeightReachedRB $block_height_reached_rb block_height_reached_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['blockHeightReached'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \com.cryptoapis.rest_apis.sdk\Model\BlockHeightReachedR|\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReached400Response|\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReached401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReached403Response|\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReached409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response
     */
    public function blockHeightReached($blockchain, $network, $context = null, $block_height_reached_rb = null, string $contentType = self::contentTypes['blockHeightReached'][0])
    {
        list($response) = $this->blockHeightReachedWithHttpInfo($blockchain, $network, $context, $block_height_reached_rb, $contentType);
        return $response;
    }

    /**
     * Operation blockHeightReachedWithHttpInfo
     *
     * Block Height Reached
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\BlockHeightReachedRB $block_height_reached_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['blockHeightReached'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \com.cryptoapis.rest_apis.sdk\Model\BlockHeightReachedR|\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReached400Response|\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReached401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReached403Response|\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReached409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function blockHeightReachedWithHttpInfo($blockchain, $network, $context = null, $block_height_reached_rb = null, string $contentType = self::contentTypes['blockHeightReached'][0])
    {
        $request = $this->blockHeightReachedRequest($blockchain, $network, $context, $block_height_reached_rb, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReachedR' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReachedR' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReachedR', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReached400Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReached400Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReached400Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReached401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReached401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReached401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 402:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReached403Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReached403Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReached403Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReached409Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReached409Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReached409Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 415:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReachedR';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReachedR',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReached400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReached401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReached403Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReached409Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation blockHeightReachedAsync
     *
     * Block Height Reached
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\BlockHeightReachedRB $block_height_reached_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['blockHeightReached'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function blockHeightReachedAsync($blockchain, $network, $context = null, $block_height_reached_rb = null, string $contentType = self::contentTypes['blockHeightReached'][0])
    {
        return $this->blockHeightReachedAsyncWithHttpInfo($blockchain, $network, $context, $block_height_reached_rb, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation blockHeightReachedAsyncWithHttpInfo
     *
     * Block Height Reached
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\BlockHeightReachedRB $block_height_reached_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['blockHeightReached'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function blockHeightReachedAsyncWithHttpInfo($blockchain, $network, $context = null, $block_height_reached_rb = null, string $contentType = self::contentTypes['blockHeightReached'][0])
    {
        $returnType = '\com.cryptoapis.rest_apis.sdk\Model\BlockHeightReachedR';
        $request = $this->blockHeightReachedRequest($blockchain, $network, $context, $block_height_reached_rb, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'blockHeightReached'
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\BlockHeightReachedRB $block_height_reached_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['blockHeightReached'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function blockHeightReachedRequest($blockchain, $network, $context = null, $block_height_reached_rb = null, string $contentType = self::contentTypes['blockHeightReached'][0])
    {

        // verify the required parameter 'blockchain' is set
        if ($blockchain === null || (is_array($blockchain) && count($blockchain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $blockchain when calling blockHeightReached'
            );
        }

        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling blockHeightReached'
            );
        }




        $resourcePath = '/blockchain-events/{blockchain}/{network}/subscriptions/block-height-reached';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($blockchain !== null) {
            $resourcePath = str_replace(
                '{' . 'blockchain' . '}',
                ObjectSerializer::toPathValue($blockchain),
                $resourcePath
            );
        }
        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($block_height_reached_rb)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($block_height_reached_rb));
            } else {
                $httpBody = $block_height_reached_rb;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation minedTransaction
     *
     * Mined Transaction
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\MinedTransactionRB $mined_transaction_rb mined_transaction_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['minedTransaction'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \com.cryptoapis.rest_apis.sdk\Model\MinedTransactionR|\com.cryptoapis.rest_apis.sdk\Model\MinedTransaction400Response|\com.cryptoapis.rest_apis.sdk\Model\MinedTransaction401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\MinedTransaction403Response|\com.cryptoapis.rest_apis.sdk\Model\MinedTransaction409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response
     */
    public function minedTransaction($blockchain, $network, $context = null, $mined_transaction_rb = null, string $contentType = self::contentTypes['minedTransaction'][0])
    {
        list($response) = $this->minedTransactionWithHttpInfo($blockchain, $network, $context, $mined_transaction_rb, $contentType);
        return $response;
    }

    /**
     * Operation minedTransactionWithHttpInfo
     *
     * Mined Transaction
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\MinedTransactionRB $mined_transaction_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['minedTransaction'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \com.cryptoapis.rest_apis.sdk\Model\MinedTransactionR|\com.cryptoapis.rest_apis.sdk\Model\MinedTransaction400Response|\com.cryptoapis.rest_apis.sdk\Model\MinedTransaction401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\MinedTransaction403Response|\com.cryptoapis.rest_apis.sdk\Model\MinedTransaction409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function minedTransactionWithHttpInfo($blockchain, $network, $context = null, $mined_transaction_rb = null, string $contentType = self::contentTypes['minedTransaction'][0])
    {
        $request = $this->minedTransactionRequest($blockchain, $network, $context, $mined_transaction_rb, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\MinedTransactionR' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\MinedTransactionR' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\MinedTransactionR', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\MinedTransaction400Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\MinedTransaction400Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\MinedTransaction400Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\MinedTransaction401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\MinedTransaction401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\MinedTransaction401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 402:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\MinedTransaction403Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\MinedTransaction403Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\MinedTransaction403Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\MinedTransaction409Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\MinedTransaction409Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\MinedTransaction409Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 415:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.cryptoapis.rest_apis.sdk\Model\MinedTransactionR';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\MinedTransactionR',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\MinedTransaction400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\MinedTransaction401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\MinedTransaction403Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\MinedTransaction409Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation minedTransactionAsync
     *
     * Mined Transaction
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\MinedTransactionRB $mined_transaction_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['minedTransaction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function minedTransactionAsync($blockchain, $network, $context = null, $mined_transaction_rb = null, string $contentType = self::contentTypes['minedTransaction'][0])
    {
        return $this->minedTransactionAsyncWithHttpInfo($blockchain, $network, $context, $mined_transaction_rb, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation minedTransactionAsyncWithHttpInfo
     *
     * Mined Transaction
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\MinedTransactionRB $mined_transaction_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['minedTransaction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function minedTransactionAsyncWithHttpInfo($blockchain, $network, $context = null, $mined_transaction_rb = null, string $contentType = self::contentTypes['minedTransaction'][0])
    {
        $returnType = '\com.cryptoapis.rest_apis.sdk\Model\MinedTransactionR';
        $request = $this->minedTransactionRequest($blockchain, $network, $context, $mined_transaction_rb, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'minedTransaction'
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\MinedTransactionRB $mined_transaction_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['minedTransaction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function minedTransactionRequest($blockchain, $network, $context = null, $mined_transaction_rb = null, string $contentType = self::contentTypes['minedTransaction'][0])
    {

        // verify the required parameter 'blockchain' is set
        if ($blockchain === null || (is_array($blockchain) && count($blockchain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $blockchain when calling minedTransaction'
            );
        }

        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling minedTransaction'
            );
        }




        $resourcePath = '/blockchain-events/{blockchain}/{network}/subscriptions/transaction-mined';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($blockchain !== null) {
            $resourcePath = str_replace(
                '{' . 'blockchain' . '}',
                ObjectSerializer::toPathValue($blockchain),
                $resourcePath
            );
        }
        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mined_transaction_rb)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mined_transaction_rb));
            } else {
                $httpBody = $mined_transaction_rb;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation newBlock
     *
     * New Block
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewBlockRB $new_block_rb new_block_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newBlock'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \com.cryptoapis.rest_apis.sdk\Model\NewBlockR|\com.cryptoapis.rest_apis.sdk\Model\NewBlock400Response|\com.cryptoapis.rest_apis.sdk\Model\NewBlock401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\NewBlock403Response|\com.cryptoapis.rest_apis.sdk\Model\NewBlock409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response
     */
    public function newBlock($blockchain, $network, $context = null, $new_block_rb = null, string $contentType = self::contentTypes['newBlock'][0])
    {
        list($response) = $this->newBlockWithHttpInfo($blockchain, $network, $context, $new_block_rb, $contentType);
        return $response;
    }

    /**
     * Operation newBlockWithHttpInfo
     *
     * New Block
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewBlockRB $new_block_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newBlock'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \com.cryptoapis.rest_apis.sdk\Model\NewBlockR|\com.cryptoapis.rest_apis.sdk\Model\NewBlock400Response|\com.cryptoapis.rest_apis.sdk\Model\NewBlock401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\NewBlock403Response|\com.cryptoapis.rest_apis.sdk\Model\NewBlock409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function newBlockWithHttpInfo($blockchain, $network, $context = null, $new_block_rb = null, string $contentType = self::contentTypes['newBlock'][0])
    {
        $request = $this->newBlockRequest($blockchain, $network, $context, $new_block_rb, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewBlockR' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewBlockR' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewBlockR', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewBlock400Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewBlock400Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewBlock400Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewBlock401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewBlock401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewBlock401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 402:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewBlock403Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewBlock403Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewBlock403Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewBlock409Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewBlock409Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewBlock409Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 415:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.cryptoapis.rest_apis.sdk\Model\NewBlockR';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewBlockR',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewBlock400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewBlock401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewBlock403Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewBlock409Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation newBlockAsync
     *
     * New Block
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewBlockRB $new_block_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newBlock'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newBlockAsync($blockchain, $network, $context = null, $new_block_rb = null, string $contentType = self::contentTypes['newBlock'][0])
    {
        return $this->newBlockAsyncWithHttpInfo($blockchain, $network, $context, $new_block_rb, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation newBlockAsyncWithHttpInfo
     *
     * New Block
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewBlockRB $new_block_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newBlock'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newBlockAsyncWithHttpInfo($blockchain, $network, $context = null, $new_block_rb = null, string $contentType = self::contentTypes['newBlock'][0])
    {
        $returnType = '\com.cryptoapis.rest_apis.sdk\Model\NewBlockR';
        $request = $this->newBlockRequest($blockchain, $network, $context, $new_block_rb, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'newBlock'
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewBlockRB $new_block_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newBlock'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function newBlockRequest($blockchain, $network, $context = null, $new_block_rb = null, string $contentType = self::contentTypes['newBlock'][0])
    {

        // verify the required parameter 'blockchain' is set
        if ($blockchain === null || (is_array($blockchain) && count($blockchain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $blockchain when calling newBlock'
            );
        }

        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling newBlock'
            );
        }




        $resourcePath = '/blockchain-events/{blockchain}/{network}/subscriptions/block-mined';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($blockchain !== null) {
            $resourcePath = str_replace(
                '{' . 'blockchain' . '}',
                ObjectSerializer::toPathValue($blockchain),
                $resourcePath
            );
        }
        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($new_block_rb)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($new_block_rb));
            } else {
                $httpBody = $new_block_rb;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation newConfirmedCoinsTransactions
     *
     * New Confirmed Coins Transactions
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsRB $new_confirmed_coins_transactions_rb new_confirmed_coins_transactions_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedCoinsTransactions'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsR|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactions400Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactions401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactions403Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactions409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response
     */
    public function newConfirmedCoinsTransactions($blockchain, $network, $context = null, $new_confirmed_coins_transactions_rb = null, string $contentType = self::contentTypes['newConfirmedCoinsTransactions'][0])
    {
        list($response) = $this->newConfirmedCoinsTransactionsWithHttpInfo($blockchain, $network, $context, $new_confirmed_coins_transactions_rb, $contentType);
        return $response;
    }

    /**
     * Operation newConfirmedCoinsTransactionsWithHttpInfo
     *
     * New Confirmed Coins Transactions
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsRB $new_confirmed_coins_transactions_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedCoinsTransactions'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsR|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactions400Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactions401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactions403Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactions409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function newConfirmedCoinsTransactionsWithHttpInfo($blockchain, $network, $context = null, $new_confirmed_coins_transactions_rb = null, string $contentType = self::contentTypes['newConfirmedCoinsTransactions'][0])
    {
        $request = $this->newConfirmedCoinsTransactionsRequest($blockchain, $network, $context, $new_confirmed_coins_transactions_rb, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsR' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsR' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsR', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactions400Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactions400Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactions400Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactions401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactions401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactions401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 402:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactions403Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactions403Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactions403Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactions409Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactions409Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactions409Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 415:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsR';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsR',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactions400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactions401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactions403Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactions409Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation newConfirmedCoinsTransactionsAsync
     *
     * New Confirmed Coins Transactions
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsRB $new_confirmed_coins_transactions_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedCoinsTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newConfirmedCoinsTransactionsAsync($blockchain, $network, $context = null, $new_confirmed_coins_transactions_rb = null, string $contentType = self::contentTypes['newConfirmedCoinsTransactions'][0])
    {
        return $this->newConfirmedCoinsTransactionsAsyncWithHttpInfo($blockchain, $network, $context, $new_confirmed_coins_transactions_rb, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation newConfirmedCoinsTransactionsAsyncWithHttpInfo
     *
     * New Confirmed Coins Transactions
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsRB $new_confirmed_coins_transactions_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedCoinsTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newConfirmedCoinsTransactionsAsyncWithHttpInfo($blockchain, $network, $context = null, $new_confirmed_coins_transactions_rb = null, string $contentType = self::contentTypes['newConfirmedCoinsTransactions'][0])
    {
        $returnType = '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsR';
        $request = $this->newConfirmedCoinsTransactionsRequest($blockchain, $network, $context, $new_confirmed_coins_transactions_rb, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'newConfirmedCoinsTransactions'
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsRB $new_confirmed_coins_transactions_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedCoinsTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function newConfirmedCoinsTransactionsRequest($blockchain, $network, $context = null, $new_confirmed_coins_transactions_rb = null, string $contentType = self::contentTypes['newConfirmedCoinsTransactions'][0])
    {

        // verify the required parameter 'blockchain' is set
        if ($blockchain === null || (is_array($blockchain) && count($blockchain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $blockchain when calling newConfirmedCoinsTransactions'
            );
        }

        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling newConfirmedCoinsTransactions'
            );
        }




        $resourcePath = '/blockchain-events/{blockchain}/{network}/subscriptions/address-coins-transactions-confirmed';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($blockchain !== null) {
            $resourcePath = str_replace(
                '{' . 'blockchain' . '}',
                ObjectSerializer::toPathValue($blockchain),
                $resourcePath
            );
        }
        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($new_confirmed_coins_transactions_rb)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($new_confirmed_coins_transactions_rb));
            } else {
                $httpBody = $new_confirmed_coins_transactions_rb;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation newConfirmedCoinsTransactionsAndEachConfirmation
     *
     * New Confirmed Coins Transactions And Each Confirmation
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmationRB $new_confirmed_coins_transactions_and_each_confirmation_rb new_confirmed_coins_transactions_and_each_confirmation_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedCoinsTransactionsAndEachConfirmation'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmationR|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmation400Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmation401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmation403Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmation409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response
     */
    public function newConfirmedCoinsTransactionsAndEachConfirmation($blockchain, $network, $context = null, $new_confirmed_coins_transactions_and_each_confirmation_rb = null, string $contentType = self::contentTypes['newConfirmedCoinsTransactionsAndEachConfirmation'][0])
    {
        list($response) = $this->newConfirmedCoinsTransactionsAndEachConfirmationWithHttpInfo($blockchain, $network, $context, $new_confirmed_coins_transactions_and_each_confirmation_rb, $contentType);
        return $response;
    }

    /**
     * Operation newConfirmedCoinsTransactionsAndEachConfirmationWithHttpInfo
     *
     * New Confirmed Coins Transactions And Each Confirmation
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmationRB $new_confirmed_coins_transactions_and_each_confirmation_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedCoinsTransactionsAndEachConfirmation'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmationR|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmation400Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmation401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmation403Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmation409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function newConfirmedCoinsTransactionsAndEachConfirmationWithHttpInfo($blockchain, $network, $context = null, $new_confirmed_coins_transactions_and_each_confirmation_rb = null, string $contentType = self::contentTypes['newConfirmedCoinsTransactionsAndEachConfirmation'][0])
    {
        $request = $this->newConfirmedCoinsTransactionsAndEachConfirmationRequest($blockchain, $network, $context, $new_confirmed_coins_transactions_and_each_confirmation_rb, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmationR' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmationR' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmationR', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmation400Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmation400Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmation400Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmation401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmation401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmation401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 402:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmation403Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmation403Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmation403Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmation409Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmation409Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmation409Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 415:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmationR';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmationR',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmation400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmation401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmation403Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmation409Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation newConfirmedCoinsTransactionsAndEachConfirmationAsync
     *
     * New Confirmed Coins Transactions And Each Confirmation
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmationRB $new_confirmed_coins_transactions_and_each_confirmation_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedCoinsTransactionsAndEachConfirmation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newConfirmedCoinsTransactionsAndEachConfirmationAsync($blockchain, $network, $context = null, $new_confirmed_coins_transactions_and_each_confirmation_rb = null, string $contentType = self::contentTypes['newConfirmedCoinsTransactionsAndEachConfirmation'][0])
    {
        return $this->newConfirmedCoinsTransactionsAndEachConfirmationAsyncWithHttpInfo($blockchain, $network, $context, $new_confirmed_coins_transactions_and_each_confirmation_rb, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation newConfirmedCoinsTransactionsAndEachConfirmationAsyncWithHttpInfo
     *
     * New Confirmed Coins Transactions And Each Confirmation
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmationRB $new_confirmed_coins_transactions_and_each_confirmation_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedCoinsTransactionsAndEachConfirmation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newConfirmedCoinsTransactionsAndEachConfirmationAsyncWithHttpInfo($blockchain, $network, $context = null, $new_confirmed_coins_transactions_and_each_confirmation_rb = null, string $contentType = self::contentTypes['newConfirmedCoinsTransactionsAndEachConfirmation'][0])
    {
        $returnType = '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmationR';
        $request = $this->newConfirmedCoinsTransactionsAndEachConfirmationRequest($blockchain, $network, $context, $new_confirmed_coins_transactions_and_each_confirmation_rb, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'newConfirmedCoinsTransactionsAndEachConfirmation'
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedCoinsTransactionsAndEachConfirmationRB $new_confirmed_coins_transactions_and_each_confirmation_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedCoinsTransactionsAndEachConfirmation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function newConfirmedCoinsTransactionsAndEachConfirmationRequest($blockchain, $network, $context = null, $new_confirmed_coins_transactions_and_each_confirmation_rb = null, string $contentType = self::contentTypes['newConfirmedCoinsTransactionsAndEachConfirmation'][0])
    {

        // verify the required parameter 'blockchain' is set
        if ($blockchain === null || (is_array($blockchain) && count($blockchain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $blockchain when calling newConfirmedCoinsTransactionsAndEachConfirmation'
            );
        }

        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling newConfirmedCoinsTransactionsAndEachConfirmation'
            );
        }




        $resourcePath = '/blockchain-events/{blockchain}/{network}/subscriptions/address-coins-transactions-confirmed-each-confirmation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($blockchain !== null) {
            $resourcePath = str_replace(
                '{' . 'blockchain' . '}',
                ObjectSerializer::toPathValue($blockchain),
                $resourcePath
            );
        }
        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($new_confirmed_coins_transactions_and_each_confirmation_rb)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($new_confirmed_coins_transactions_and_each_confirmation_rb));
            } else {
                $httpBody = $new_confirmed_coins_transactions_and_each_confirmation_rb;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation newConfirmedInternalTransactions
     *
     * New Confirmed Internal Transactions
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsRB $new_confirmed_internal_transactions_rb new_confirmed_internal_transactions_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedInternalTransactions'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsR|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactions400Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactions401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactions403Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactions409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response
     */
    public function newConfirmedInternalTransactions($blockchain, $network, $context = null, $new_confirmed_internal_transactions_rb = null, string $contentType = self::contentTypes['newConfirmedInternalTransactions'][0])
    {
        list($response) = $this->newConfirmedInternalTransactionsWithHttpInfo($blockchain, $network, $context, $new_confirmed_internal_transactions_rb, $contentType);
        return $response;
    }

    /**
     * Operation newConfirmedInternalTransactionsWithHttpInfo
     *
     * New Confirmed Internal Transactions
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsRB $new_confirmed_internal_transactions_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedInternalTransactions'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsR|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactions400Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactions401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactions403Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactions409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function newConfirmedInternalTransactionsWithHttpInfo($blockchain, $network, $context = null, $new_confirmed_internal_transactions_rb = null, string $contentType = self::contentTypes['newConfirmedInternalTransactions'][0])
    {
        $request = $this->newConfirmedInternalTransactionsRequest($blockchain, $network, $context, $new_confirmed_internal_transactions_rb, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsR' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsR' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsR', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactions400Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactions400Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactions400Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactions401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactions401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactions401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 402:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactions403Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactions403Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactions403Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactions409Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactions409Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactions409Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 415:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsR';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsR',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactions400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactions401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactions403Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactions409Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation newConfirmedInternalTransactionsAsync
     *
     * New Confirmed Internal Transactions
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsRB $new_confirmed_internal_transactions_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedInternalTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newConfirmedInternalTransactionsAsync($blockchain, $network, $context = null, $new_confirmed_internal_transactions_rb = null, string $contentType = self::contentTypes['newConfirmedInternalTransactions'][0])
    {
        return $this->newConfirmedInternalTransactionsAsyncWithHttpInfo($blockchain, $network, $context, $new_confirmed_internal_transactions_rb, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation newConfirmedInternalTransactionsAsyncWithHttpInfo
     *
     * New Confirmed Internal Transactions
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsRB $new_confirmed_internal_transactions_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedInternalTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newConfirmedInternalTransactionsAsyncWithHttpInfo($blockchain, $network, $context = null, $new_confirmed_internal_transactions_rb = null, string $contentType = self::contentTypes['newConfirmedInternalTransactions'][0])
    {
        $returnType = '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsR';
        $request = $this->newConfirmedInternalTransactionsRequest($blockchain, $network, $context, $new_confirmed_internal_transactions_rb, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'newConfirmedInternalTransactions'
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsRB $new_confirmed_internal_transactions_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedInternalTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function newConfirmedInternalTransactionsRequest($blockchain, $network, $context = null, $new_confirmed_internal_transactions_rb = null, string $contentType = self::contentTypes['newConfirmedInternalTransactions'][0])
    {

        // verify the required parameter 'blockchain' is set
        if ($blockchain === null || (is_array($blockchain) && count($blockchain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $blockchain when calling newConfirmedInternalTransactions'
            );
        }

        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling newConfirmedInternalTransactions'
            );
        }




        $resourcePath = '/blockchain-events/{blockchain}/{network}/subscriptions/address-internal-transactions-confirmed';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($blockchain !== null) {
            $resourcePath = str_replace(
                '{' . 'blockchain' . '}',
                ObjectSerializer::toPathValue($blockchain),
                $resourcePath
            );
        }
        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($new_confirmed_internal_transactions_rb)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($new_confirmed_internal_transactions_rb));
            } else {
                $httpBody = $new_confirmed_internal_transactions_rb;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation newConfirmedInternalTransactionsAndEachConfirmation
     *
     * New Confirmed Internal Transactions And Each Confirmation
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmationRB $new_confirmed_internal_transactions_and_each_confirmation_rb new_confirmed_internal_transactions_and_each_confirmation_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedInternalTransactionsAndEachConfirmation'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmationR|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmation400Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmation401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmation403Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmation409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response
     */
    public function newConfirmedInternalTransactionsAndEachConfirmation($blockchain, $network, $context = null, $new_confirmed_internal_transactions_and_each_confirmation_rb = null, string $contentType = self::contentTypes['newConfirmedInternalTransactionsAndEachConfirmation'][0])
    {
        list($response) = $this->newConfirmedInternalTransactionsAndEachConfirmationWithHttpInfo($blockchain, $network, $context, $new_confirmed_internal_transactions_and_each_confirmation_rb, $contentType);
        return $response;
    }

    /**
     * Operation newConfirmedInternalTransactionsAndEachConfirmationWithHttpInfo
     *
     * New Confirmed Internal Transactions And Each Confirmation
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmationRB $new_confirmed_internal_transactions_and_each_confirmation_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedInternalTransactionsAndEachConfirmation'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmationR|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmation400Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmation401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmation403Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmation409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function newConfirmedInternalTransactionsAndEachConfirmationWithHttpInfo($blockchain, $network, $context = null, $new_confirmed_internal_transactions_and_each_confirmation_rb = null, string $contentType = self::contentTypes['newConfirmedInternalTransactionsAndEachConfirmation'][0])
    {
        $request = $this->newConfirmedInternalTransactionsAndEachConfirmationRequest($blockchain, $network, $context, $new_confirmed_internal_transactions_and_each_confirmation_rb, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmationR' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmationR' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmationR', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmation400Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmation400Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmation400Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmation401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmation401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmation401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 402:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmation403Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmation403Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmation403Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmation409Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmation409Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmation409Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 415:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmationR';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmationR',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmation400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmation401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmation403Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmation409Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation newConfirmedInternalTransactionsAndEachConfirmationAsync
     *
     * New Confirmed Internal Transactions And Each Confirmation
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmationRB $new_confirmed_internal_transactions_and_each_confirmation_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedInternalTransactionsAndEachConfirmation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newConfirmedInternalTransactionsAndEachConfirmationAsync($blockchain, $network, $context = null, $new_confirmed_internal_transactions_and_each_confirmation_rb = null, string $contentType = self::contentTypes['newConfirmedInternalTransactionsAndEachConfirmation'][0])
    {
        return $this->newConfirmedInternalTransactionsAndEachConfirmationAsyncWithHttpInfo($blockchain, $network, $context, $new_confirmed_internal_transactions_and_each_confirmation_rb, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation newConfirmedInternalTransactionsAndEachConfirmationAsyncWithHttpInfo
     *
     * New Confirmed Internal Transactions And Each Confirmation
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmationRB $new_confirmed_internal_transactions_and_each_confirmation_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedInternalTransactionsAndEachConfirmation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newConfirmedInternalTransactionsAndEachConfirmationAsyncWithHttpInfo($blockchain, $network, $context = null, $new_confirmed_internal_transactions_and_each_confirmation_rb = null, string $contentType = self::contentTypes['newConfirmedInternalTransactionsAndEachConfirmation'][0])
    {
        $returnType = '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmationR';
        $request = $this->newConfirmedInternalTransactionsAndEachConfirmationRequest($blockchain, $network, $context, $new_confirmed_internal_transactions_and_each_confirmation_rb, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'newConfirmedInternalTransactionsAndEachConfirmation'
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedInternalTransactionsAndEachConfirmationRB $new_confirmed_internal_transactions_and_each_confirmation_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedInternalTransactionsAndEachConfirmation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function newConfirmedInternalTransactionsAndEachConfirmationRequest($blockchain, $network, $context = null, $new_confirmed_internal_transactions_and_each_confirmation_rb = null, string $contentType = self::contentTypes['newConfirmedInternalTransactionsAndEachConfirmation'][0])
    {

        // verify the required parameter 'blockchain' is set
        if ($blockchain === null || (is_array($blockchain) && count($blockchain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $blockchain when calling newConfirmedInternalTransactionsAndEachConfirmation'
            );
        }

        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling newConfirmedInternalTransactionsAndEachConfirmation'
            );
        }




        $resourcePath = '/blockchain-events/{blockchain}/{network}/subscriptions/address-internal-transactions-confirmed-each-confirmation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($blockchain !== null) {
            $resourcePath = str_replace(
                '{' . 'blockchain' . '}',
                ObjectSerializer::toPathValue($blockchain),
                $resourcePath
            );
        }
        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($new_confirmed_internal_transactions_and_each_confirmation_rb)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($new_confirmed_internal_transactions_and_each_confirmation_rb));
            } else {
                $httpBody = $new_confirmed_internal_transactions_and_each_confirmation_rb;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation newConfirmedTokensTransactions
     *
     * New Confirmed Tokens Transactions
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsRB $new_confirmed_tokens_transactions_rb new_confirmed_tokens_transactions_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedTokensTransactions'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsR|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactions400Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactions401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactions403Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactions409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response
     */
    public function newConfirmedTokensTransactions($blockchain, $network, $context = null, $new_confirmed_tokens_transactions_rb = null, string $contentType = self::contentTypes['newConfirmedTokensTransactions'][0])
    {
        list($response) = $this->newConfirmedTokensTransactionsWithHttpInfo($blockchain, $network, $context, $new_confirmed_tokens_transactions_rb, $contentType);
        return $response;
    }

    /**
     * Operation newConfirmedTokensTransactionsWithHttpInfo
     *
     * New Confirmed Tokens Transactions
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsRB $new_confirmed_tokens_transactions_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedTokensTransactions'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsR|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactions400Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactions401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactions403Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactions409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function newConfirmedTokensTransactionsWithHttpInfo($blockchain, $network, $context = null, $new_confirmed_tokens_transactions_rb = null, string $contentType = self::contentTypes['newConfirmedTokensTransactions'][0])
    {
        $request = $this->newConfirmedTokensTransactionsRequest($blockchain, $network, $context, $new_confirmed_tokens_transactions_rb, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsR' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsR' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsR', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactions400Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactions400Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactions400Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactions401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactions401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactions401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 402:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactions403Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactions403Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactions403Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactions409Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactions409Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactions409Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 415:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsR';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsR',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactions400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactions401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactions403Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactions409Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation newConfirmedTokensTransactionsAsync
     *
     * New Confirmed Tokens Transactions
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsRB $new_confirmed_tokens_transactions_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedTokensTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newConfirmedTokensTransactionsAsync($blockchain, $network, $context = null, $new_confirmed_tokens_transactions_rb = null, string $contentType = self::contentTypes['newConfirmedTokensTransactions'][0])
    {
        return $this->newConfirmedTokensTransactionsAsyncWithHttpInfo($blockchain, $network, $context, $new_confirmed_tokens_transactions_rb, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation newConfirmedTokensTransactionsAsyncWithHttpInfo
     *
     * New Confirmed Tokens Transactions
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsRB $new_confirmed_tokens_transactions_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedTokensTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newConfirmedTokensTransactionsAsyncWithHttpInfo($blockchain, $network, $context = null, $new_confirmed_tokens_transactions_rb = null, string $contentType = self::contentTypes['newConfirmedTokensTransactions'][0])
    {
        $returnType = '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsR';
        $request = $this->newConfirmedTokensTransactionsRequest($blockchain, $network, $context, $new_confirmed_tokens_transactions_rb, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'newConfirmedTokensTransactions'
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsRB $new_confirmed_tokens_transactions_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedTokensTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function newConfirmedTokensTransactionsRequest($blockchain, $network, $context = null, $new_confirmed_tokens_transactions_rb = null, string $contentType = self::contentTypes['newConfirmedTokensTransactions'][0])
    {

        // verify the required parameter 'blockchain' is set
        if ($blockchain === null || (is_array($blockchain) && count($blockchain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $blockchain when calling newConfirmedTokensTransactions'
            );
        }

        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling newConfirmedTokensTransactions'
            );
        }




        $resourcePath = '/blockchain-events/{blockchain}/{network}/subscriptions/address-tokens-transactions-confirmed';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($blockchain !== null) {
            $resourcePath = str_replace(
                '{' . 'blockchain' . '}',
                ObjectSerializer::toPathValue($blockchain),
                $resourcePath
            );
        }
        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($new_confirmed_tokens_transactions_rb)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($new_confirmed_tokens_transactions_rb));
            } else {
                $httpBody = $new_confirmed_tokens_transactions_rb;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation newConfirmedTokensTransactionsAndEachConfirmation
     *
     * New Confirmed Tokens Transactions And Each Confirmation
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmationRB $new_confirmed_tokens_transactions_and_each_confirmation_rb new_confirmed_tokens_transactions_and_each_confirmation_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedTokensTransactionsAndEachConfirmation'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmationR|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmation400Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmation401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmation403Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmation409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response
     */
    public function newConfirmedTokensTransactionsAndEachConfirmation($blockchain, $network, $context = null, $new_confirmed_tokens_transactions_and_each_confirmation_rb = null, string $contentType = self::contentTypes['newConfirmedTokensTransactionsAndEachConfirmation'][0])
    {
        list($response) = $this->newConfirmedTokensTransactionsAndEachConfirmationWithHttpInfo($blockchain, $network, $context, $new_confirmed_tokens_transactions_and_each_confirmation_rb, $contentType);
        return $response;
    }

    /**
     * Operation newConfirmedTokensTransactionsAndEachConfirmationWithHttpInfo
     *
     * New Confirmed Tokens Transactions And Each Confirmation
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmationRB $new_confirmed_tokens_transactions_and_each_confirmation_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedTokensTransactionsAndEachConfirmation'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmationR|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmation400Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmation401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmation403Response|\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmation409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function newConfirmedTokensTransactionsAndEachConfirmationWithHttpInfo($blockchain, $network, $context = null, $new_confirmed_tokens_transactions_and_each_confirmation_rb = null, string $contentType = self::contentTypes['newConfirmedTokensTransactionsAndEachConfirmation'][0])
    {
        $request = $this->newConfirmedTokensTransactionsAndEachConfirmationRequest($blockchain, $network, $context, $new_confirmed_tokens_transactions_and_each_confirmation_rb, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmationR' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmationR' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmationR', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmation400Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmation400Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmation400Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmation401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmation401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmation401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 402:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmation403Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmation403Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmation403Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmation409Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmation409Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmation409Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 415:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmationR';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmationR',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmation400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmation401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmation403Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmation409Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation newConfirmedTokensTransactionsAndEachConfirmationAsync
     *
     * New Confirmed Tokens Transactions And Each Confirmation
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmationRB $new_confirmed_tokens_transactions_and_each_confirmation_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedTokensTransactionsAndEachConfirmation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newConfirmedTokensTransactionsAndEachConfirmationAsync($blockchain, $network, $context = null, $new_confirmed_tokens_transactions_and_each_confirmation_rb = null, string $contentType = self::contentTypes['newConfirmedTokensTransactionsAndEachConfirmation'][0])
    {
        return $this->newConfirmedTokensTransactionsAndEachConfirmationAsyncWithHttpInfo($blockchain, $network, $context, $new_confirmed_tokens_transactions_and_each_confirmation_rb, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation newConfirmedTokensTransactionsAndEachConfirmationAsyncWithHttpInfo
     *
     * New Confirmed Tokens Transactions And Each Confirmation
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmationRB $new_confirmed_tokens_transactions_and_each_confirmation_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedTokensTransactionsAndEachConfirmation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newConfirmedTokensTransactionsAndEachConfirmationAsyncWithHttpInfo($blockchain, $network, $context = null, $new_confirmed_tokens_transactions_and_each_confirmation_rb = null, string $contentType = self::contentTypes['newConfirmedTokensTransactionsAndEachConfirmation'][0])
    {
        $returnType = '\com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmationR';
        $request = $this->newConfirmedTokensTransactionsAndEachConfirmationRequest($blockchain, $network, $context, $new_confirmed_tokens_transactions_and_each_confirmation_rb, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'newConfirmedTokensTransactionsAndEachConfirmation'
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewConfirmedTokensTransactionsAndEachConfirmationRB $new_confirmed_tokens_transactions_and_each_confirmation_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newConfirmedTokensTransactionsAndEachConfirmation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function newConfirmedTokensTransactionsAndEachConfirmationRequest($blockchain, $network, $context = null, $new_confirmed_tokens_transactions_and_each_confirmation_rb = null, string $contentType = self::contentTypes['newConfirmedTokensTransactionsAndEachConfirmation'][0])
    {

        // verify the required parameter 'blockchain' is set
        if ($blockchain === null || (is_array($blockchain) && count($blockchain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $blockchain when calling newConfirmedTokensTransactionsAndEachConfirmation'
            );
        }

        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling newConfirmedTokensTransactionsAndEachConfirmation'
            );
        }




        $resourcePath = '/blockchain-events/{blockchain}/{network}/subscriptions/address-tokens-transactions-confirmed-each-confirmation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($blockchain !== null) {
            $resourcePath = str_replace(
                '{' . 'blockchain' . '}',
                ObjectSerializer::toPathValue($blockchain),
                $resourcePath
            );
        }
        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($new_confirmed_tokens_transactions_and_each_confirmation_rb)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($new_confirmed_tokens_transactions_and_each_confirmation_rb));
            } else {
                $httpBody = $new_confirmed_tokens_transactions_and_each_confirmation_rb;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation newRevertedBlock
     *
     * New Reverted Block
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlockRB $new_reverted_block_rb new_reverted_block_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newRevertedBlock'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlockR|\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlock400Response|\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlock401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlock403Response|\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlock409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response
     */
    public function newRevertedBlock($blockchain, $network, $context = null, $new_reverted_block_rb = null, string $contentType = self::contentTypes['newRevertedBlock'][0])
    {
        list($response) = $this->newRevertedBlockWithHttpInfo($blockchain, $network, $context, $new_reverted_block_rb, $contentType);
        return $response;
    }

    /**
     * Operation newRevertedBlockWithHttpInfo
     *
     * New Reverted Block
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlockRB $new_reverted_block_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newRevertedBlock'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlockR|\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlock400Response|\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlock401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlock403Response|\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlock409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function newRevertedBlockWithHttpInfo($blockchain, $network, $context = null, $new_reverted_block_rb = null, string $contentType = self::contentTypes['newRevertedBlock'][0])
    {
        $request = $this->newRevertedBlockRequest($blockchain, $network, $context, $new_reverted_block_rb, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlockR' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlockR' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlockR', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlock400Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlock400Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlock400Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlock401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlock401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlock401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 402:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlock403Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlock403Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlock403Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlock409Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlock409Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlock409Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 415:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlockR';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlockR',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlock400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlock401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlock403Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlock409Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation newRevertedBlockAsync
     *
     * New Reverted Block
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlockRB $new_reverted_block_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newRevertedBlock'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newRevertedBlockAsync($blockchain, $network, $context = null, $new_reverted_block_rb = null, string $contentType = self::contentTypes['newRevertedBlock'][0])
    {
        return $this->newRevertedBlockAsyncWithHttpInfo($blockchain, $network, $context, $new_reverted_block_rb, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation newRevertedBlockAsyncWithHttpInfo
     *
     * New Reverted Block
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlockRB $new_reverted_block_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newRevertedBlock'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newRevertedBlockAsyncWithHttpInfo($blockchain, $network, $context = null, $new_reverted_block_rb = null, string $contentType = self::contentTypes['newRevertedBlock'][0])
    {
        $returnType = '\com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlockR';
        $request = $this->newRevertedBlockRequest($blockchain, $network, $context, $new_reverted_block_rb, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'newRevertedBlock'
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewRevertedBlockRB $new_reverted_block_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newRevertedBlock'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function newRevertedBlockRequest($blockchain, $network, $context = null, $new_reverted_block_rb = null, string $contentType = self::contentTypes['newRevertedBlock'][0])
    {

        // verify the required parameter 'blockchain' is set
        if ($blockchain === null || (is_array($blockchain) && count($blockchain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $blockchain when calling newRevertedBlock'
            );
        }

        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling newRevertedBlock'
            );
        }




        $resourcePath = '/blockchain-events/{blockchain}/{network}/subscriptions/reverted-block';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($blockchain !== null) {
            $resourcePath = str_replace(
                '{' . 'blockchain' . '}',
                ObjectSerializer::toPathValue($blockchain),
                $resourcePath
            );
        }
        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($new_reverted_block_rb)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($new_reverted_block_rb));
            } else {
                $httpBody = $new_reverted_block_rb;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation newUnconfirmedCoinsTransactions
     *
     * New Unconfirmed Coins Transactions
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactionsRB $new_unconfirmed_coins_transactions_rb new_unconfirmed_coins_transactions_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newUnconfirmedCoinsTransactions'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactionsR|\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactions400Response|\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactions401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactions403Response|\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactions409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response
     */
    public function newUnconfirmedCoinsTransactions($blockchain, $network, $context = null, $new_unconfirmed_coins_transactions_rb = null, string $contentType = self::contentTypes['newUnconfirmedCoinsTransactions'][0])
    {
        list($response) = $this->newUnconfirmedCoinsTransactionsWithHttpInfo($blockchain, $network, $context, $new_unconfirmed_coins_transactions_rb, $contentType);
        return $response;
    }

    /**
     * Operation newUnconfirmedCoinsTransactionsWithHttpInfo
     *
     * New Unconfirmed Coins Transactions
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactionsRB $new_unconfirmed_coins_transactions_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newUnconfirmedCoinsTransactions'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactionsR|\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactions400Response|\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactions401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactions403Response|\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactions409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function newUnconfirmedCoinsTransactionsWithHttpInfo($blockchain, $network, $context = null, $new_unconfirmed_coins_transactions_rb = null, string $contentType = self::contentTypes['newUnconfirmedCoinsTransactions'][0])
    {
        $request = $this->newUnconfirmedCoinsTransactionsRequest($blockchain, $network, $context, $new_unconfirmed_coins_transactions_rb, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactionsR' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactionsR' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactionsR', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactions400Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactions400Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactions400Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactions401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactions401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactions401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 402:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactions403Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactions403Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactions403Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactions409Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactions409Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactions409Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 415:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactionsR';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactionsR',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactions400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactions401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactions403Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactions409Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation newUnconfirmedCoinsTransactionsAsync
     *
     * New Unconfirmed Coins Transactions
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactionsRB $new_unconfirmed_coins_transactions_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newUnconfirmedCoinsTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newUnconfirmedCoinsTransactionsAsync($blockchain, $network, $context = null, $new_unconfirmed_coins_transactions_rb = null, string $contentType = self::contentTypes['newUnconfirmedCoinsTransactions'][0])
    {
        return $this->newUnconfirmedCoinsTransactionsAsyncWithHttpInfo($blockchain, $network, $context, $new_unconfirmed_coins_transactions_rb, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation newUnconfirmedCoinsTransactionsAsyncWithHttpInfo
     *
     * New Unconfirmed Coins Transactions
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactionsRB $new_unconfirmed_coins_transactions_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newUnconfirmedCoinsTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newUnconfirmedCoinsTransactionsAsyncWithHttpInfo($blockchain, $network, $context = null, $new_unconfirmed_coins_transactions_rb = null, string $contentType = self::contentTypes['newUnconfirmedCoinsTransactions'][0])
    {
        $returnType = '\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactionsR';
        $request = $this->newUnconfirmedCoinsTransactionsRequest($blockchain, $network, $context, $new_unconfirmed_coins_transactions_rb, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'newUnconfirmedCoinsTransactions'
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedCoinsTransactionsRB $new_unconfirmed_coins_transactions_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newUnconfirmedCoinsTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function newUnconfirmedCoinsTransactionsRequest($blockchain, $network, $context = null, $new_unconfirmed_coins_transactions_rb = null, string $contentType = self::contentTypes['newUnconfirmedCoinsTransactions'][0])
    {

        // verify the required parameter 'blockchain' is set
        if ($blockchain === null || (is_array($blockchain) && count($blockchain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $blockchain when calling newUnconfirmedCoinsTransactions'
            );
        }

        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling newUnconfirmedCoinsTransactions'
            );
        }




        $resourcePath = '/blockchain-events/{blockchain}/{network}/subscriptions/address-coins-transactions-unconfirmed';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($blockchain !== null) {
            $resourcePath = str_replace(
                '{' . 'blockchain' . '}',
                ObjectSerializer::toPathValue($blockchain),
                $resourcePath
            );
        }
        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($new_unconfirmed_coins_transactions_rb)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($new_unconfirmed_coins_transactions_rb));
            } else {
                $httpBody = $new_unconfirmed_coins_transactions_rb;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation newUnconfirmedTokensTransactions
     *
     * New Unconfirmed Tokens Transactions
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactionsRB $new_unconfirmed_tokens_transactions_rb new_unconfirmed_tokens_transactions_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newUnconfirmedTokensTransactions'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactionsR|\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactions400Response|\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactions401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactions403Response|\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactions409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response
     */
    public function newUnconfirmedTokensTransactions($blockchain, $network, $context = null, $new_unconfirmed_tokens_transactions_rb = null, string $contentType = self::contentTypes['newUnconfirmedTokensTransactions'][0])
    {
        list($response) = $this->newUnconfirmedTokensTransactionsWithHttpInfo($blockchain, $network, $context, $new_unconfirmed_tokens_transactions_rb, $contentType);
        return $response;
    }

    /**
     * Operation newUnconfirmedTokensTransactionsWithHttpInfo
     *
     * New Unconfirmed Tokens Transactions
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactionsRB $new_unconfirmed_tokens_transactions_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newUnconfirmedTokensTransactions'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactionsR|\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactions400Response|\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactions401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactions403Response|\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactions409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function newUnconfirmedTokensTransactionsWithHttpInfo($blockchain, $network, $context = null, $new_unconfirmed_tokens_transactions_rb = null, string $contentType = self::contentTypes['newUnconfirmedTokensTransactions'][0])
    {
        $request = $this->newUnconfirmedTokensTransactionsRequest($blockchain, $network, $context, $new_unconfirmed_tokens_transactions_rb, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactionsR' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactionsR' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactionsR', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactions400Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactions400Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactions400Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactions401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactions401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactions401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 402:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactions403Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactions403Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactions403Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactions409Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactions409Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactions409Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 415:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactionsR';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactionsR',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactions400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactions401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactions403Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactions409Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation newUnconfirmedTokensTransactionsAsync
     *
     * New Unconfirmed Tokens Transactions
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactionsRB $new_unconfirmed_tokens_transactions_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newUnconfirmedTokensTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newUnconfirmedTokensTransactionsAsync($blockchain, $network, $context = null, $new_unconfirmed_tokens_transactions_rb = null, string $contentType = self::contentTypes['newUnconfirmedTokensTransactions'][0])
    {
        return $this->newUnconfirmedTokensTransactionsAsyncWithHttpInfo($blockchain, $network, $context, $new_unconfirmed_tokens_transactions_rb, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation newUnconfirmedTokensTransactionsAsyncWithHttpInfo
     *
     * New Unconfirmed Tokens Transactions
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactionsRB $new_unconfirmed_tokens_transactions_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newUnconfirmedTokensTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function newUnconfirmedTokensTransactionsAsyncWithHttpInfo($blockchain, $network, $context = null, $new_unconfirmed_tokens_transactions_rb = null, string $contentType = self::contentTypes['newUnconfirmedTokensTransactions'][0])
    {
        $returnType = '\com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactionsR';
        $request = $this->newUnconfirmedTokensTransactionsRequest($blockchain, $network, $context, $new_unconfirmed_tokens_transactions_rb, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'newUnconfirmedTokensTransactions'
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;ropsten\&quot; are test networks. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\NewUnconfirmedTokensTransactionsRB $new_unconfirmed_tokens_transactions_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['newUnconfirmedTokensTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function newUnconfirmedTokensTransactionsRequest($blockchain, $network, $context = null, $new_unconfirmed_tokens_transactions_rb = null, string $contentType = self::contentTypes['newUnconfirmedTokensTransactions'][0])
    {

        // verify the required parameter 'blockchain' is set
        if ($blockchain === null || (is_array($blockchain) && count($blockchain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $blockchain when calling newUnconfirmedTokensTransactions'
            );
        }

        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling newUnconfirmedTokensTransactions'
            );
        }




        $resourcePath = '/blockchain-events/{blockchain}/{network}/subscriptions/address-tokens-transactions-unconfirmed';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($blockchain !== null) {
            $resourcePath = str_replace(
                '{' . 'blockchain' . '}',
                ObjectSerializer::toPathValue($blockchain),
                $resourcePath
            );
        }
        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($new_unconfirmed_tokens_transactions_rb)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($new_unconfirmed_tokens_transactions_rb));
            } else {
                $httpBody = $new_unconfirmed_tokens_transactions_rb;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
