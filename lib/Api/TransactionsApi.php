<?php
/**
 * TransactionsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  com.cryptoapis.rest_apis.sdk
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * CryptoAPIs
 *
 * Crypto APIs is a complex and innovative infrastructure layer that radically simplifies the development of any Blockchain and Crypto related applications. Organized around REST, Crypto APIs can assist both novice Bitcoin/Ethereum enthusiasts and crypto experts with the development of their blockchain applications. Crypto APIs provides unified endpoints and data, raw data, automatic tokens and coins forwardings, callback functionalities, and much more.
 *
 * The version of the OpenAPI document: 2023-04-25
 * Contact: developers@cryptoapis.io
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.4.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace com.cryptoapis.rest_apis.sdk\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use com.cryptoapis.rest_apis.sdk\ApiException;
use com.cryptoapis.rest_apis.sdk\Configuration;
use com.cryptoapis.rest_apis.sdk\HeaderSelector;
use com.cryptoapis.rest_apis.sdk\ObjectSerializer;

/**
 * TransactionsApi Class Doc Comment
 *
 * @category Class
 * @package  com.cryptoapis.rest_apis.sdk
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class TransactionsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'createCoinsTransactionFromAddressForWholeAmount' => [
            'application/json',
        ],
        'createCoinsTransactionRequestFromAddress' => [
            'application/json',
        ],
        'createCoinsTransactionRequestFromWallet' => [
            'application/json',
        ],
        'createFungibleTokenTransactionRequestFromAddressWithoutFeePriority' => [
            'application/json',
        ],
        'createFungibleTokensTransactionRequestFromAddress' => [
            'application/json',
        ],
        'createSingleTransactionRequestFromAddressWithoutFeePriority' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createCoinsTransactionFromAddressForWholeAmount
     *
     * Create Coins Transaction From Address For Whole Amount
     *
     * @param  string $address Defines the source address. (required)
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $wallet_id Represents the sender&#39;s specific and unique Wallet ID of the sender. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmountRB $create_coins_transaction_from_address_for_whole_amount_rb create_coins_transaction_from_address_for_whole_amount_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCoinsTransactionFromAddressForWholeAmount'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmountR|\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmount400Response|\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmount401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmount403Response|\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmount409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response
     */
    public function createCoinsTransactionFromAddressForWholeAmount($address, $blockchain, $network, $wallet_id, $context = null, $create_coins_transaction_from_address_for_whole_amount_rb = null, string $contentType = self::contentTypes['createCoinsTransactionFromAddressForWholeAmount'][0])
    {
        list($response) = $this->createCoinsTransactionFromAddressForWholeAmountWithHttpInfo($address, $blockchain, $network, $wallet_id, $context, $create_coins_transaction_from_address_for_whole_amount_rb, $contentType);
        return $response;
    }

    /**
     * Operation createCoinsTransactionFromAddressForWholeAmountWithHttpInfo
     *
     * Create Coins Transaction From Address For Whole Amount
     *
     * @param  string $address Defines the source address. (required)
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $wallet_id Represents the sender&#39;s specific and unique Wallet ID of the sender. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmountRB $create_coins_transaction_from_address_for_whole_amount_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCoinsTransactionFromAddressForWholeAmount'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmountR|\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmount400Response|\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmount401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmount403Response|\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmount409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoinsTransactionFromAddressForWholeAmountWithHttpInfo($address, $blockchain, $network, $wallet_id, $context = null, $create_coins_transaction_from_address_for_whole_amount_rb = null, string $contentType = self::contentTypes['createCoinsTransactionFromAddressForWholeAmount'][0])
    {
        $request = $this->createCoinsTransactionFromAddressForWholeAmountRequest($address, $blockchain, $network, $wallet_id, $context, $create_coins_transaction_from_address_for_whole_amount_rb, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmountR' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmountR' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmountR', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmount400Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmount400Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmount400Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmount401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmount401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmount401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 402:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmount403Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmount403Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmount403Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmount409Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmount409Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmount409Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 415:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmountR';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmountR',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmount400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmount401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmount403Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmount409Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createCoinsTransactionFromAddressForWholeAmountAsync
     *
     * Create Coins Transaction From Address For Whole Amount
     *
     * @param  string $address Defines the source address. (required)
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $wallet_id Represents the sender&#39;s specific and unique Wallet ID of the sender. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmountRB $create_coins_transaction_from_address_for_whole_amount_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCoinsTransactionFromAddressForWholeAmount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCoinsTransactionFromAddressForWholeAmountAsync($address, $blockchain, $network, $wallet_id, $context = null, $create_coins_transaction_from_address_for_whole_amount_rb = null, string $contentType = self::contentTypes['createCoinsTransactionFromAddressForWholeAmount'][0])
    {
        return $this->createCoinsTransactionFromAddressForWholeAmountAsyncWithHttpInfo($address, $blockchain, $network, $wallet_id, $context, $create_coins_transaction_from_address_for_whole_amount_rb, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCoinsTransactionFromAddressForWholeAmountAsyncWithHttpInfo
     *
     * Create Coins Transaction From Address For Whole Amount
     *
     * @param  string $address Defines the source address. (required)
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $wallet_id Represents the sender&#39;s specific and unique Wallet ID of the sender. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmountRB $create_coins_transaction_from_address_for_whole_amount_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCoinsTransactionFromAddressForWholeAmount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCoinsTransactionFromAddressForWholeAmountAsyncWithHttpInfo($address, $blockchain, $network, $wallet_id, $context = null, $create_coins_transaction_from_address_for_whole_amount_rb = null, string $contentType = self::contentTypes['createCoinsTransactionFromAddressForWholeAmount'][0])
    {
        $returnType = '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmountR';
        $request = $this->createCoinsTransactionFromAddressForWholeAmountRequest($address, $blockchain, $network, $wallet_id, $context, $create_coins_transaction_from_address_for_whole_amount_rb, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCoinsTransactionFromAddressForWholeAmount'
     *
     * @param  string $address Defines the source address. (required)
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $wallet_id Represents the sender&#39;s specific and unique Wallet ID of the sender. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionFromAddressForWholeAmountRB $create_coins_transaction_from_address_for_whole_amount_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCoinsTransactionFromAddressForWholeAmount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createCoinsTransactionFromAddressForWholeAmountRequest($address, $blockchain, $network, $wallet_id, $context = null, $create_coins_transaction_from_address_for_whole_amount_rb = null, string $contentType = self::contentTypes['createCoinsTransactionFromAddressForWholeAmount'][0])
    {

        // verify the required parameter 'address' is set
        if ($address === null || (is_array($address) && count($address) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address when calling createCoinsTransactionFromAddressForWholeAmount'
            );
        }

        // verify the required parameter 'blockchain' is set
        if ($blockchain === null || (is_array($blockchain) && count($blockchain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $blockchain when calling createCoinsTransactionFromAddressForWholeAmount'
            );
        }

        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling createCoinsTransactionFromAddressForWholeAmount'
            );
        }

        // verify the required parameter 'wallet_id' is set
        if ($wallet_id === null || (is_array($wallet_id) && count($wallet_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $wallet_id when calling createCoinsTransactionFromAddressForWholeAmount'
            );
        }




        $resourcePath = '/wallet-as-a-service/wallets/{walletId}/{blockchain}/{network}/addresses/{address}/all-transaction-requests';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($address !== null) {
            $resourcePath = str_replace(
                '{' . 'address' . '}',
                ObjectSerializer::toPathValue($address),
                $resourcePath
            );
        }
        // path params
        if ($blockchain !== null) {
            $resourcePath = str_replace(
                '{' . 'blockchain' . '}',
                ObjectSerializer::toPathValue($blockchain),
                $resourcePath
            );
        }
        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }
        // path params
        if ($wallet_id !== null) {
            $resourcePath = str_replace(
                '{' . 'walletId' . '}',
                ObjectSerializer::toPathValue($wallet_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_coins_transaction_from_address_for_whole_amount_rb)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_coins_transaction_from_address_for_whole_amount_rb));
            } else {
                $httpBody = $create_coins_transaction_from_address_for_whole_amount_rb;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCoinsTransactionRequestFromAddress
     *
     * Create Coins Transaction Request from Address
     *
     * @param  string $address Defines the specific source address for the transaction. For XRP we also support the X-address format. (required)
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $wallet_id Represents the sender&#39;s specific and unique Wallet ID of the sender. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddressRB $create_coins_transaction_request_from_address_rb create_coins_transaction_request_from_address_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCoinsTransactionRequestFromAddress'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddressR|\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddress400Response|\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddress401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddress403Response|\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddress409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response
     */
    public function createCoinsTransactionRequestFromAddress($address, $blockchain, $network, $wallet_id, $context = null, $create_coins_transaction_request_from_address_rb = null, string $contentType = self::contentTypes['createCoinsTransactionRequestFromAddress'][0])
    {
        list($response) = $this->createCoinsTransactionRequestFromAddressWithHttpInfo($address, $blockchain, $network, $wallet_id, $context, $create_coins_transaction_request_from_address_rb, $contentType);
        return $response;
    }

    /**
     * Operation createCoinsTransactionRequestFromAddressWithHttpInfo
     *
     * Create Coins Transaction Request from Address
     *
     * @param  string $address Defines the specific source address for the transaction. For XRP we also support the X-address format. (required)
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $wallet_id Represents the sender&#39;s specific and unique Wallet ID of the sender. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddressRB $create_coins_transaction_request_from_address_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCoinsTransactionRequestFromAddress'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddressR|\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddress400Response|\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddress401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddress403Response|\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddress409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoinsTransactionRequestFromAddressWithHttpInfo($address, $blockchain, $network, $wallet_id, $context = null, $create_coins_transaction_request_from_address_rb = null, string $contentType = self::contentTypes['createCoinsTransactionRequestFromAddress'][0])
    {
        $request = $this->createCoinsTransactionRequestFromAddressRequest($address, $blockchain, $network, $wallet_id, $context, $create_coins_transaction_request_from_address_rb, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddressR' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddressR' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddressR', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddress400Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddress400Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddress400Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddress401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddress401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddress401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 402:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddress403Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddress403Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddress403Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddress409Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddress409Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddress409Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 415:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddressR';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddressR',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddress400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddress401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddress403Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddress409Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createCoinsTransactionRequestFromAddressAsync
     *
     * Create Coins Transaction Request from Address
     *
     * @param  string $address Defines the specific source address for the transaction. For XRP we also support the X-address format. (required)
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $wallet_id Represents the sender&#39;s specific and unique Wallet ID of the sender. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddressRB $create_coins_transaction_request_from_address_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCoinsTransactionRequestFromAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCoinsTransactionRequestFromAddressAsync($address, $blockchain, $network, $wallet_id, $context = null, $create_coins_transaction_request_from_address_rb = null, string $contentType = self::contentTypes['createCoinsTransactionRequestFromAddress'][0])
    {
        return $this->createCoinsTransactionRequestFromAddressAsyncWithHttpInfo($address, $blockchain, $network, $wallet_id, $context, $create_coins_transaction_request_from_address_rb, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCoinsTransactionRequestFromAddressAsyncWithHttpInfo
     *
     * Create Coins Transaction Request from Address
     *
     * @param  string $address Defines the specific source address for the transaction. For XRP we also support the X-address format. (required)
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $wallet_id Represents the sender&#39;s specific and unique Wallet ID of the sender. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddressRB $create_coins_transaction_request_from_address_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCoinsTransactionRequestFromAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCoinsTransactionRequestFromAddressAsyncWithHttpInfo($address, $blockchain, $network, $wallet_id, $context = null, $create_coins_transaction_request_from_address_rb = null, string $contentType = self::contentTypes['createCoinsTransactionRequestFromAddress'][0])
    {
        $returnType = '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddressR';
        $request = $this->createCoinsTransactionRequestFromAddressRequest($address, $blockchain, $network, $wallet_id, $context, $create_coins_transaction_request_from_address_rb, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCoinsTransactionRequestFromAddress'
     *
     * @param  string $address Defines the specific source address for the transaction. For XRP we also support the X-address format. (required)
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $wallet_id Represents the sender&#39;s specific and unique Wallet ID of the sender. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromAddressRB $create_coins_transaction_request_from_address_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCoinsTransactionRequestFromAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createCoinsTransactionRequestFromAddressRequest($address, $blockchain, $network, $wallet_id, $context = null, $create_coins_transaction_request_from_address_rb = null, string $contentType = self::contentTypes['createCoinsTransactionRequestFromAddress'][0])
    {

        // verify the required parameter 'address' is set
        if ($address === null || (is_array($address) && count($address) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address when calling createCoinsTransactionRequestFromAddress'
            );
        }

        // verify the required parameter 'blockchain' is set
        if ($blockchain === null || (is_array($blockchain) && count($blockchain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $blockchain when calling createCoinsTransactionRequestFromAddress'
            );
        }

        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling createCoinsTransactionRequestFromAddress'
            );
        }

        // verify the required parameter 'wallet_id' is set
        if ($wallet_id === null || (is_array($wallet_id) && count($wallet_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $wallet_id when calling createCoinsTransactionRequestFromAddress'
            );
        }




        $resourcePath = '/wallet-as-a-service/wallets/{walletId}/{blockchain}/{network}/addresses/{address}/transaction-requests';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($address !== null) {
            $resourcePath = str_replace(
                '{' . 'address' . '}',
                ObjectSerializer::toPathValue($address),
                $resourcePath
            );
        }
        // path params
        if ($blockchain !== null) {
            $resourcePath = str_replace(
                '{' . 'blockchain' . '}',
                ObjectSerializer::toPathValue($blockchain),
                $resourcePath
            );
        }
        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }
        // path params
        if ($wallet_id !== null) {
            $resourcePath = str_replace(
                '{' . 'walletId' . '}',
                ObjectSerializer::toPathValue($wallet_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_coins_transaction_request_from_address_rb)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_coins_transaction_request_from_address_rb));
            } else {
                $httpBody = $create_coins_transaction_request_from_address_rb;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createCoinsTransactionRequestFromWallet
     *
     * Create Coins Transaction Request from Wallet
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $wallet_id Represents the sender&#39;s specific and unique Wallet ID of the sender. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWalletRB $create_coins_transaction_request_from_wallet_rb create_coins_transaction_request_from_wallet_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCoinsTransactionRequestFromWallet'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWalletR|\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWallet400Response|\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWallet401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWallet403Response|\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWallet409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response
     */
    public function createCoinsTransactionRequestFromWallet($blockchain, $network, $wallet_id, $context = null, $create_coins_transaction_request_from_wallet_rb = null, string $contentType = self::contentTypes['createCoinsTransactionRequestFromWallet'][0])
    {
        list($response) = $this->createCoinsTransactionRequestFromWalletWithHttpInfo($blockchain, $network, $wallet_id, $context, $create_coins_transaction_request_from_wallet_rb, $contentType);
        return $response;
    }

    /**
     * Operation createCoinsTransactionRequestFromWalletWithHttpInfo
     *
     * Create Coins Transaction Request from Wallet
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $wallet_id Represents the sender&#39;s specific and unique Wallet ID of the sender. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWalletRB $create_coins_transaction_request_from_wallet_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCoinsTransactionRequestFromWallet'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWalletR|\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWallet400Response|\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWallet401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWallet403Response|\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWallet409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCoinsTransactionRequestFromWalletWithHttpInfo($blockchain, $network, $wallet_id, $context = null, $create_coins_transaction_request_from_wallet_rb = null, string $contentType = self::contentTypes['createCoinsTransactionRequestFromWallet'][0])
    {
        $request = $this->createCoinsTransactionRequestFromWalletRequest($blockchain, $network, $wallet_id, $context, $create_coins_transaction_request_from_wallet_rb, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWalletR' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWalletR' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWalletR', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWallet400Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWallet400Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWallet400Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWallet401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWallet401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWallet401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 402:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWallet403Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWallet403Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWallet403Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWallet409Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWallet409Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWallet409Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 415:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWalletR';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWalletR',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWallet400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWallet401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWallet403Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWallet409Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createCoinsTransactionRequestFromWalletAsync
     *
     * Create Coins Transaction Request from Wallet
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $wallet_id Represents the sender&#39;s specific and unique Wallet ID of the sender. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWalletRB $create_coins_transaction_request_from_wallet_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCoinsTransactionRequestFromWallet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCoinsTransactionRequestFromWalletAsync($blockchain, $network, $wallet_id, $context = null, $create_coins_transaction_request_from_wallet_rb = null, string $contentType = self::contentTypes['createCoinsTransactionRequestFromWallet'][0])
    {
        return $this->createCoinsTransactionRequestFromWalletAsyncWithHttpInfo($blockchain, $network, $wallet_id, $context, $create_coins_transaction_request_from_wallet_rb, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCoinsTransactionRequestFromWalletAsyncWithHttpInfo
     *
     * Create Coins Transaction Request from Wallet
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $wallet_id Represents the sender&#39;s specific and unique Wallet ID of the sender. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWalletRB $create_coins_transaction_request_from_wallet_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCoinsTransactionRequestFromWallet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCoinsTransactionRequestFromWalletAsyncWithHttpInfo($blockchain, $network, $wallet_id, $context = null, $create_coins_transaction_request_from_wallet_rb = null, string $contentType = self::contentTypes['createCoinsTransactionRequestFromWallet'][0])
    {
        $returnType = '\com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWalletR';
        $request = $this->createCoinsTransactionRequestFromWalletRequest($blockchain, $network, $wallet_id, $context, $create_coins_transaction_request_from_wallet_rb, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCoinsTransactionRequestFromWallet'
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $wallet_id Represents the sender&#39;s specific and unique Wallet ID of the sender. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateCoinsTransactionRequestFromWalletRB $create_coins_transaction_request_from_wallet_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createCoinsTransactionRequestFromWallet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createCoinsTransactionRequestFromWalletRequest($blockchain, $network, $wallet_id, $context = null, $create_coins_transaction_request_from_wallet_rb = null, string $contentType = self::contentTypes['createCoinsTransactionRequestFromWallet'][0])
    {

        // verify the required parameter 'blockchain' is set
        if ($blockchain === null || (is_array($blockchain) && count($blockchain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $blockchain when calling createCoinsTransactionRequestFromWallet'
            );
        }

        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling createCoinsTransactionRequestFromWallet'
            );
        }

        // verify the required parameter 'wallet_id' is set
        if ($wallet_id === null || (is_array($wallet_id) && count($wallet_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $wallet_id when calling createCoinsTransactionRequestFromWallet'
            );
        }




        $resourcePath = '/wallet-as-a-service/wallets/{walletId}/{blockchain}/{network}/transaction-requests';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($blockchain !== null) {
            $resourcePath = str_replace(
                '{' . 'blockchain' . '}',
                ObjectSerializer::toPathValue($blockchain),
                $resourcePath
            );
        }
        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }
        // path params
        if ($wallet_id !== null) {
            $resourcePath = str_replace(
                '{' . 'walletId' . '}',
                ObjectSerializer::toPathValue($wallet_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_coins_transaction_request_from_wallet_rb)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_coins_transaction_request_from_wallet_rb));
            } else {
                $httpBody = $create_coins_transaction_request_from_wallet_rb;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createFungibleTokenTransactionRequestFromAddressWithoutFeePriority
     *
     * Create Fungible Token Transaction Request From Address Without Fee Priority
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $sender_address Defines the specific source address for the transaction. (required)
     * @param  string $wallet_id Defines the unique ID of the Wallet. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriorityRB $create_fungible_token_transaction_request_from_address_without_fee_priority_rb create_fungible_token_transaction_request_from_address_without_fee_priority_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFungibleTokenTransactionRequestFromAddressWithoutFeePriority'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriorityR|\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriority400Response|\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriority401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriority403Response|\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriority409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response
     */
    public function createFungibleTokenTransactionRequestFromAddressWithoutFeePriority($blockchain, $network, $sender_address, $wallet_id, $context = null, $create_fungible_token_transaction_request_from_address_without_fee_priority_rb = null, string $contentType = self::contentTypes['createFungibleTokenTransactionRequestFromAddressWithoutFeePriority'][0])
    {
        list($response) = $this->createFungibleTokenTransactionRequestFromAddressWithoutFeePriorityWithHttpInfo($blockchain, $network, $sender_address, $wallet_id, $context, $create_fungible_token_transaction_request_from_address_without_fee_priority_rb, $contentType);
        return $response;
    }

    /**
     * Operation createFungibleTokenTransactionRequestFromAddressWithoutFeePriorityWithHttpInfo
     *
     * Create Fungible Token Transaction Request From Address Without Fee Priority
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $sender_address Defines the specific source address for the transaction. (required)
     * @param  string $wallet_id Defines the unique ID of the Wallet. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriorityRB $create_fungible_token_transaction_request_from_address_without_fee_priority_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFungibleTokenTransactionRequestFromAddressWithoutFeePriority'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriorityR|\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriority400Response|\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriority401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriority403Response|\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriority409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createFungibleTokenTransactionRequestFromAddressWithoutFeePriorityWithHttpInfo($blockchain, $network, $sender_address, $wallet_id, $context = null, $create_fungible_token_transaction_request_from_address_without_fee_priority_rb = null, string $contentType = self::contentTypes['createFungibleTokenTransactionRequestFromAddressWithoutFeePriority'][0])
    {
        $request = $this->createFungibleTokenTransactionRequestFromAddressWithoutFeePriorityRequest($blockchain, $network, $sender_address, $wallet_id, $context, $create_fungible_token_transaction_request_from_address_without_fee_priority_rb, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriorityR' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriorityR' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriorityR', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriority400Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriority400Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriority400Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriority401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriority401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriority401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 402:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriority403Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriority403Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriority403Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriority409Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriority409Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriority409Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 415:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriorityR';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriorityR',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriority400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriority401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriority403Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriority409Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createFungibleTokenTransactionRequestFromAddressWithoutFeePriorityAsync
     *
     * Create Fungible Token Transaction Request From Address Without Fee Priority
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $sender_address Defines the specific source address for the transaction. (required)
     * @param  string $wallet_id Defines the unique ID of the Wallet. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriorityRB $create_fungible_token_transaction_request_from_address_without_fee_priority_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFungibleTokenTransactionRequestFromAddressWithoutFeePriority'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFungibleTokenTransactionRequestFromAddressWithoutFeePriorityAsync($blockchain, $network, $sender_address, $wallet_id, $context = null, $create_fungible_token_transaction_request_from_address_without_fee_priority_rb = null, string $contentType = self::contentTypes['createFungibleTokenTransactionRequestFromAddressWithoutFeePriority'][0])
    {
        return $this->createFungibleTokenTransactionRequestFromAddressWithoutFeePriorityAsyncWithHttpInfo($blockchain, $network, $sender_address, $wallet_id, $context, $create_fungible_token_transaction_request_from_address_without_fee_priority_rb, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createFungibleTokenTransactionRequestFromAddressWithoutFeePriorityAsyncWithHttpInfo
     *
     * Create Fungible Token Transaction Request From Address Without Fee Priority
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $sender_address Defines the specific source address for the transaction. (required)
     * @param  string $wallet_id Defines the unique ID of the Wallet. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriorityRB $create_fungible_token_transaction_request_from_address_without_fee_priority_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFungibleTokenTransactionRequestFromAddressWithoutFeePriority'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFungibleTokenTransactionRequestFromAddressWithoutFeePriorityAsyncWithHttpInfo($blockchain, $network, $sender_address, $wallet_id, $context = null, $create_fungible_token_transaction_request_from_address_without_fee_priority_rb = null, string $contentType = self::contentTypes['createFungibleTokenTransactionRequestFromAddressWithoutFeePriority'][0])
    {
        $returnType = '\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriorityR';
        $request = $this->createFungibleTokenTransactionRequestFromAddressWithoutFeePriorityRequest($blockchain, $network, $sender_address, $wallet_id, $context, $create_fungible_token_transaction_request_from_address_without_fee_priority_rb, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createFungibleTokenTransactionRequestFromAddressWithoutFeePriority'
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $sender_address Defines the specific source address for the transaction. (required)
     * @param  string $wallet_id Defines the unique ID of the Wallet. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokenTransactionRequestFromAddressWithoutFeePriorityRB $create_fungible_token_transaction_request_from_address_without_fee_priority_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFungibleTokenTransactionRequestFromAddressWithoutFeePriority'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createFungibleTokenTransactionRequestFromAddressWithoutFeePriorityRequest($blockchain, $network, $sender_address, $wallet_id, $context = null, $create_fungible_token_transaction_request_from_address_without_fee_priority_rb = null, string $contentType = self::contentTypes['createFungibleTokenTransactionRequestFromAddressWithoutFeePriority'][0])
    {

        // verify the required parameter 'blockchain' is set
        if ($blockchain === null || (is_array($blockchain) && count($blockchain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $blockchain when calling createFungibleTokenTransactionRequestFromAddressWithoutFeePriority'
            );
        }

        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling createFungibleTokenTransactionRequestFromAddressWithoutFeePriority'
            );
        }

        // verify the required parameter 'sender_address' is set
        if ($sender_address === null || (is_array($sender_address) && count($sender_address) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sender_address when calling createFungibleTokenTransactionRequestFromAddressWithoutFeePriority'
            );
        }

        // verify the required parameter 'wallet_id' is set
        if ($wallet_id === null || (is_array($wallet_id) && count($wallet_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $wallet_id when calling createFungibleTokenTransactionRequestFromAddressWithoutFeePriority'
            );
        }




        $resourcePath = '/wallet-as-a-service/wallets/{walletId}/{blockchain}/{network}/addresses/{senderAddress}/feeless-token-transaction-requests';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($blockchain !== null) {
            $resourcePath = str_replace(
                '{' . 'blockchain' . '}',
                ObjectSerializer::toPathValue($blockchain),
                $resourcePath
            );
        }
        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }
        // path params
        if ($sender_address !== null) {
            $resourcePath = str_replace(
                '{' . 'senderAddress' . '}',
                ObjectSerializer::toPathValue($sender_address),
                $resourcePath
            );
        }
        // path params
        if ($wallet_id !== null) {
            $resourcePath = str_replace(
                '{' . 'walletId' . '}',
                ObjectSerializer::toPathValue($wallet_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_fungible_token_transaction_request_from_address_without_fee_priority_rb)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_fungible_token_transaction_request_from_address_without_fee_priority_rb));
            } else {
                $httpBody = $create_fungible_token_transaction_request_from_address_without_fee_priority_rb;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createFungibleTokensTransactionRequestFromAddress
     *
     * Create Fungible Tokens Transaction Request from Address
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $sender_address Defines the specific source address for the transaction. (required)
     * @param  string $wallet_id Defines the unique ID of the Wallet. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddressRB $create_fungible_tokens_transaction_request_from_address_rb create_fungible_tokens_transaction_request_from_address_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFungibleTokensTransactionRequestFromAddress'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddressR|\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddress400Response|\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddress401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddress403Response|\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddress409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response
     */
    public function createFungibleTokensTransactionRequestFromAddress($blockchain, $network, $sender_address, $wallet_id, $context = null, $create_fungible_tokens_transaction_request_from_address_rb = null, string $contentType = self::contentTypes['createFungibleTokensTransactionRequestFromAddress'][0])
    {
        list($response) = $this->createFungibleTokensTransactionRequestFromAddressWithHttpInfo($blockchain, $network, $sender_address, $wallet_id, $context, $create_fungible_tokens_transaction_request_from_address_rb, $contentType);
        return $response;
    }

    /**
     * Operation createFungibleTokensTransactionRequestFromAddressWithHttpInfo
     *
     * Create Fungible Tokens Transaction Request from Address
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $sender_address Defines the specific source address for the transaction. (required)
     * @param  string $wallet_id Defines the unique ID of the Wallet. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddressRB $create_fungible_tokens_transaction_request_from_address_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFungibleTokensTransactionRequestFromAddress'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddressR|\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddress400Response|\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddress401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddress403Response|\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddress409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createFungibleTokensTransactionRequestFromAddressWithHttpInfo($blockchain, $network, $sender_address, $wallet_id, $context = null, $create_fungible_tokens_transaction_request_from_address_rb = null, string $contentType = self::contentTypes['createFungibleTokensTransactionRequestFromAddress'][0])
    {
        $request = $this->createFungibleTokensTransactionRequestFromAddressRequest($blockchain, $network, $sender_address, $wallet_id, $context, $create_fungible_tokens_transaction_request_from_address_rb, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddressR' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddressR' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddressR', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddress400Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddress400Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddress400Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddress401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddress401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddress401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 402:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddress403Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddress403Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddress403Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddress409Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddress409Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddress409Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 415:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddressR';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddressR',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddress400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddress401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddress403Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddress409Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createFungibleTokensTransactionRequestFromAddressAsync
     *
     * Create Fungible Tokens Transaction Request from Address
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $sender_address Defines the specific source address for the transaction. (required)
     * @param  string $wallet_id Defines the unique ID of the Wallet. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddressRB $create_fungible_tokens_transaction_request_from_address_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFungibleTokensTransactionRequestFromAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFungibleTokensTransactionRequestFromAddressAsync($blockchain, $network, $sender_address, $wallet_id, $context = null, $create_fungible_tokens_transaction_request_from_address_rb = null, string $contentType = self::contentTypes['createFungibleTokensTransactionRequestFromAddress'][0])
    {
        return $this->createFungibleTokensTransactionRequestFromAddressAsyncWithHttpInfo($blockchain, $network, $sender_address, $wallet_id, $context, $create_fungible_tokens_transaction_request_from_address_rb, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createFungibleTokensTransactionRequestFromAddressAsyncWithHttpInfo
     *
     * Create Fungible Tokens Transaction Request from Address
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $sender_address Defines the specific source address for the transaction. (required)
     * @param  string $wallet_id Defines the unique ID of the Wallet. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddressRB $create_fungible_tokens_transaction_request_from_address_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFungibleTokensTransactionRequestFromAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFungibleTokensTransactionRequestFromAddressAsyncWithHttpInfo($blockchain, $network, $sender_address, $wallet_id, $context = null, $create_fungible_tokens_transaction_request_from_address_rb = null, string $contentType = self::contentTypes['createFungibleTokensTransactionRequestFromAddress'][0])
    {
        $returnType = '\com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddressR';
        $request = $this->createFungibleTokensTransactionRequestFromAddressRequest($blockchain, $network, $sender_address, $wallet_id, $context, $create_fungible_tokens_transaction_request_from_address_rb, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createFungibleTokensTransactionRequestFromAddress'
     *
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $sender_address Defines the specific source address for the transaction. (required)
     * @param  string $wallet_id Defines the unique ID of the Wallet. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateFungibleTokensTransactionRequestFromAddressRB $create_fungible_tokens_transaction_request_from_address_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFungibleTokensTransactionRequestFromAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createFungibleTokensTransactionRequestFromAddressRequest($blockchain, $network, $sender_address, $wallet_id, $context = null, $create_fungible_tokens_transaction_request_from_address_rb = null, string $contentType = self::contentTypes['createFungibleTokensTransactionRequestFromAddress'][0])
    {

        // verify the required parameter 'blockchain' is set
        if ($blockchain === null || (is_array($blockchain) && count($blockchain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $blockchain when calling createFungibleTokensTransactionRequestFromAddress'
            );
        }

        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling createFungibleTokensTransactionRequestFromAddress'
            );
        }

        // verify the required parameter 'sender_address' is set
        if ($sender_address === null || (is_array($sender_address) && count($sender_address) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sender_address when calling createFungibleTokensTransactionRequestFromAddress'
            );
        }

        // verify the required parameter 'wallet_id' is set
        if ($wallet_id === null || (is_array($wallet_id) && count($wallet_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $wallet_id when calling createFungibleTokensTransactionRequestFromAddress'
            );
        }




        $resourcePath = '/wallet-as-a-service/wallets/{walletId}/{blockchain}/{network}/addresses/{senderAddress}/token-transaction-requests';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($blockchain !== null) {
            $resourcePath = str_replace(
                '{' . 'blockchain' . '}',
                ObjectSerializer::toPathValue($blockchain),
                $resourcePath
            );
        }
        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }
        // path params
        if ($sender_address !== null) {
            $resourcePath = str_replace(
                '{' . 'senderAddress' . '}',
                ObjectSerializer::toPathValue($sender_address),
                $resourcePath
            );
        }
        // path params
        if ($wallet_id !== null) {
            $resourcePath = str_replace(
                '{' . 'walletId' . '}',
                ObjectSerializer::toPathValue($wallet_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_fungible_tokens_transaction_request_from_address_rb)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_fungible_tokens_transaction_request_from_address_rb));
            } else {
                $httpBody = $create_fungible_tokens_transaction_request_from_address_rb;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createSingleTransactionRequestFromAddressWithoutFeePriority
     *
     * Create Single Transaction Request From Address Without Fee Priority
     *
     * @param  string $address Defines the specific source address for the transaction. (required)
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $wallet_id Represents the sender&#39;s specific and unique Wallet ID of the sender. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriorityRB $create_single_transaction_request_from_address_without_fee_priority_rb create_single_transaction_request_from_address_without_fee_priority_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSingleTransactionRequestFromAddressWithoutFeePriority'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriorityR|\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriority400Response|\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriority401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriority403Response|\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriority409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response
     */
    public function createSingleTransactionRequestFromAddressWithoutFeePriority($address, $blockchain, $network, $wallet_id, $context = null, $create_single_transaction_request_from_address_without_fee_priority_rb = null, string $contentType = self::contentTypes['createSingleTransactionRequestFromAddressWithoutFeePriority'][0])
    {
        list($response) = $this->createSingleTransactionRequestFromAddressWithoutFeePriorityWithHttpInfo($address, $blockchain, $network, $wallet_id, $context, $create_single_transaction_request_from_address_without_fee_priority_rb, $contentType);
        return $response;
    }

    /**
     * Operation createSingleTransactionRequestFromAddressWithoutFeePriorityWithHttpInfo
     *
     * Create Single Transaction Request From Address Without Fee Priority
     *
     * @param  string $address Defines the specific source address for the transaction. (required)
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $wallet_id Represents the sender&#39;s specific and unique Wallet ID of the sender. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriorityRB $create_single_transaction_request_from_address_without_fee_priority_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSingleTransactionRequestFromAddressWithoutFeePriority'] to see the possible values for this operation
     *
     * @throws \com.cryptoapis.rest_apis.sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriorityR|\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriority400Response|\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriority401Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response|\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriority403Response|\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriority409Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response|\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function createSingleTransactionRequestFromAddressWithoutFeePriorityWithHttpInfo($address, $blockchain, $network, $wallet_id, $context = null, $create_single_transaction_request_from_address_without_fee_priority_rb = null, string $contentType = self::contentTypes['createSingleTransactionRequestFromAddressWithoutFeePriority'][0])
    {
        $request = $this->createSingleTransactionRequestFromAddressWithoutFeePriorityRequest($address, $blockchain, $network, $wallet_id, $context, $create_single_transaction_request_from_address_without_fee_priority_rb, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriorityR' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriorityR' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriorityR', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriority400Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriority400Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriority400Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 401:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriority401Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriority401Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriority401Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 402:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriority403Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriority403Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriority403Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriority409Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriority409Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriority409Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 415:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 429:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriorityR';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriorityR',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriority400Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriority401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 402:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress402Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriority403Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriority409Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress415Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress422Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress429Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\com.cryptoapis.rest_apis.sdk\Model\ConvertBitcoinCashAddress500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createSingleTransactionRequestFromAddressWithoutFeePriorityAsync
     *
     * Create Single Transaction Request From Address Without Fee Priority
     *
     * @param  string $address Defines the specific source address for the transaction. (required)
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $wallet_id Represents the sender&#39;s specific and unique Wallet ID of the sender. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriorityRB $create_single_transaction_request_from_address_without_fee_priority_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSingleTransactionRequestFromAddressWithoutFeePriority'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createSingleTransactionRequestFromAddressWithoutFeePriorityAsync($address, $blockchain, $network, $wallet_id, $context = null, $create_single_transaction_request_from_address_without_fee_priority_rb = null, string $contentType = self::contentTypes['createSingleTransactionRequestFromAddressWithoutFeePriority'][0])
    {
        return $this->createSingleTransactionRequestFromAddressWithoutFeePriorityAsyncWithHttpInfo($address, $blockchain, $network, $wallet_id, $context, $create_single_transaction_request_from_address_without_fee_priority_rb, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createSingleTransactionRequestFromAddressWithoutFeePriorityAsyncWithHttpInfo
     *
     * Create Single Transaction Request From Address Without Fee Priority
     *
     * @param  string $address Defines the specific source address for the transaction. (required)
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $wallet_id Represents the sender&#39;s specific and unique Wallet ID of the sender. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriorityRB $create_single_transaction_request_from_address_without_fee_priority_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSingleTransactionRequestFromAddressWithoutFeePriority'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createSingleTransactionRequestFromAddressWithoutFeePriorityAsyncWithHttpInfo($address, $blockchain, $network, $wallet_id, $context = null, $create_single_transaction_request_from_address_without_fee_priority_rb = null, string $contentType = self::contentTypes['createSingleTransactionRequestFromAddressWithoutFeePriority'][0])
    {
        $returnType = '\com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriorityR';
        $request = $this->createSingleTransactionRequestFromAddressWithoutFeePriorityRequest($address, $blockchain, $network, $wallet_id, $context, $create_single_transaction_request_from_address_without_fee_priority_rb, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createSingleTransactionRequestFromAddressWithoutFeePriority'
     *
     * @param  string $address Defines the specific source address for the transaction. (required)
     * @param  string $blockchain Represents the specific blockchain protocol name, e.g. Ethereum, Bitcoin, etc. (required)
     * @param  string $network Represents the name of the blockchain network used; blockchain networks are usually identical as technology and software, but they differ in data, e.g. - \&quot;mainnet\&quot; is the live network with actual data while networks like \&quot;testnet\&quot;, \&quot;goerli\&quot; are test networks. (required)
     * @param  string $wallet_id Represents the sender&#39;s specific and unique Wallet ID of the sender. (required)
     * @param  string $context In batch situations the user can use the context to correlate responses with requests. This property is present regardless of whether the response was successful or returned as an error. &#x60;context&#x60; is specified by the user. (optional)
     * @param  \com.cryptoapis.rest_apis.sdk\Model\CreateSingleTransactionRequestFromAddressWithoutFeePriorityRB $create_single_transaction_request_from_address_without_fee_priority_rb (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSingleTransactionRequestFromAddressWithoutFeePriority'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createSingleTransactionRequestFromAddressWithoutFeePriorityRequest($address, $blockchain, $network, $wallet_id, $context = null, $create_single_transaction_request_from_address_without_fee_priority_rb = null, string $contentType = self::contentTypes['createSingleTransactionRequestFromAddressWithoutFeePriority'][0])
    {

        // verify the required parameter 'address' is set
        if ($address === null || (is_array($address) && count($address) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $address when calling createSingleTransactionRequestFromAddressWithoutFeePriority'
            );
        }

        // verify the required parameter 'blockchain' is set
        if ($blockchain === null || (is_array($blockchain) && count($blockchain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $blockchain when calling createSingleTransactionRequestFromAddressWithoutFeePriority'
            );
        }

        // verify the required parameter 'network' is set
        if ($network === null || (is_array($network) && count($network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network when calling createSingleTransactionRequestFromAddressWithoutFeePriority'
            );
        }

        // verify the required parameter 'wallet_id' is set
        if ($wallet_id === null || (is_array($wallet_id) && count($wallet_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $wallet_id when calling createSingleTransactionRequestFromAddressWithoutFeePriority'
            );
        }




        $resourcePath = '/wallet-as-a-service/wallets/{walletId}/{blockchain}/{network}/addresses/{address}/feeless-transaction-requests';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $context,
            'context', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($address !== null) {
            $resourcePath = str_replace(
                '{' . 'address' . '}',
                ObjectSerializer::toPathValue($address),
                $resourcePath
            );
        }
        // path params
        if ($blockchain !== null) {
            $resourcePath = str_replace(
                '{' . 'blockchain' . '}',
                ObjectSerializer::toPathValue($blockchain),
                $resourcePath
            );
        }
        // path params
        if ($network !== null) {
            $resourcePath = str_replace(
                '{' . 'network' . '}',
                ObjectSerializer::toPathValue($network),
                $resourcePath
            );
        }
        // path params
        if ($wallet_id !== null) {
            $resourcePath = str_replace(
                '{' . 'walletId' . '}',
                ObjectSerializer::toPathValue($wallet_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_single_transaction_request_from_address_without_fee_priority_rb)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_single_transaction_request_from_address_without_fee_priority_rb));
            } else {
                $httpBody = $create_single_transaction_request_from_address_without_fee_priority_rb;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
